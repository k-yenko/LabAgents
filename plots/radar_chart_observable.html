<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computational Chemistry Agent Performance - Radar Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 20px;
            background: #f8f9fa;
        }
        .chart-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            max-width: 800px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <div class="chart-container">
        <h1>Multi-Dimensional Model Performance</h1>
        <p class="subtitle">Normalized: Each dimension scaled 0-1 (Excludes Opus - incomplete data)</p>
        <div id="chart"></div>
    </div>

    <script>
        // Model performance data from our analysis
        const modelData = [
            {name: "Claude Sonnet 4", completion: 1.000, correctness: 1.000, toolUse: 1.000, passRate: 1.000, speed: 0.290, consistency: 1.000},
            {name: "Gemini 2.5 Pro", completion: 1.000, correctness: 0.357, toolUse: 1.000, passRate: 1.000, speed: 0.000, consistency: 1.000},
            {name: "Grok Code Fast", completion: 0.688, correctness: 0.714, toolUse: 0.812, passRate: 0.400, speed: 0.494, consistency: 1.000},
            {name: "GPT-5", completion: 0.500, correctness: 0.429, toolUse: 0.875, passRate: 0.400, speed: 0.379, consistency: 1.000},
            {name: "Grok 4 Fast", completion: 0.500, correctness: 0.571, toolUse: 0.750, passRate: 0.200, speed: 0.792, consistency: 1.000},
            {name: "O3", completion: 0.125, correctness: 0.000, toolUse: 0.500, passRate: 0.000, speed: 0.921, consistency: 1.000},
            {name: "Deepseek", completion: 0.000, correctness: 0.000, toolUse: 0.500, passRate: 0.000, speed: 0.157, consistency: 1.000}
        ];

        // Metrics (axes) - better distributed to prevent overlap
        const metrics = ["Completion", "Correctness", "Tool Use", "Speed", "Pass Rate", "Consistency"];

        // Transform data into points format needed by Observable Plot
        const points = [];
        modelData.forEach(model => {
            metrics.forEach(metric => {
                const key = metric;
                let value;
                switch(metric) {
                    case "Completion": value = model.completion; break;
                    case "Correctness": value = model.correctness; break;
                    case "Tool Use": value = model.toolUse; break;
                    case "Pass Rate": value = model.passRate; break;
                    case "Speed": value = model.speed; break;
                    case "Consistency": value = model.consistency; break;
                }
                // Scale to 0.5 max (as per Observable example)
                points.push({
                    name: model.name,
                    key: key,
                    value: value * 0.5
                });
            });
        });

        // Create custom longitude positioning to avoid overlap
        const longitude = d3.scaleOrdinal()
            .domain(metrics)
            .range([0, 60, 120, 180, 240, 300]); // Custom angles to better distribute labels

        // Create the plot using Observable Plot
        const chart = Plot.plot({
            width: 600,
            height: 600,
            projection: {
                type: "azimuthal-equidistant",
                rotate: [0, -90],
                // Increased radius to accommodate moved labels and prevent overlap
                domain: d3.geoCircle().center([0, 90]).radius(0.7)()
            },
            color: {
                legend: true,
                domain: modelData.map(d => d.name),
                range: ["#17becf", "#ff7f0e", "#9467bd", "#d62728", "#2ca02c", "#1f77b4", "#8c564b"]
            },
            marks: [
                // Grey discs (grid circles)
                Plot.geo([0.5, 0.4, 0.3, 0.2, 0.1], {
                    geometry: (r) => d3.geoCircle().center([0, 90]).radius(r)(),
                    stroke: "black",
                    fill: "black",
                    strokeOpacity: 0.3,
                    fillOpacity: 0.03,
                    strokeWidth: 0.5
                }),

                // White axes
                Plot.link(longitude.domain(), {
                    x1: longitude,
                    y1: 90 - 0.62, // Match the label position
                    x2: 0,
                    y2: 90,
                    stroke: "white",
                    strokeOpacity: 0.5,
                    strokeWidth: 2.5
                }),

                // Tick labels
                Plot.text([0.1, 0.2, 0.3, 0.4, 0.5], {
                    x: 180,
                    y: (d) => 90 - d,
                    dx: 2,
                    textAnchor: "start",
                    text: (d) => `${Math.round(100 * d / 0.5)}%`, // Convert back to percentage
                    fill: "currentColor",
                    stroke: "white",
                    fontSize: 10
                }),

                // Axes labels with dynamic positioning to avoid overlap
                Plot.text(longitude.domain(), {
                    x: longitude,
                    y: (d) => {
                        const angle = longitude(d);
                        // Push labels at bottom (around 270Â°) further out
                        if (angle > 200 && angle < 340) {
                            return 90 - 0.68; // Extra distance for bottom labels
                        }
                        return 90 - 0.62; // Normal distance for other labels
                    },
                    text: Plot.identity,
                    lineWidth: 5,
                    fontSize: 12,
                    fontWeight: "bold",
                    textAnchor: "middle"
                }),

                // Areas
                Plot.area(points, {
                    x1: ({ key }) => longitude(key),
                    y1: ({ value }) => 90 - value,
                    x2: 0,
                    y2: 90,
                    fill: "name",
                    stroke: "name",
                    curve: "cardinal-closed"
                }),

                // Points
                Plot.dot(points, {
                    x: ({ key }) => longitude(key),
                    y: ({ value }) => 90 - value,
                    fill: "name",
                    stroke: "white",
                    strokeWidth: 1,
                    r: 3
                }),

                // Interactive labels
                Plot.text(
                    points,
                    Plot.pointer({
                        x: ({ key }) => longitude(key),
                        y: ({ value }) => 90 - value,
                        text: (d) => `${Math.round(100 * d.value / 0.5)}%`, // Convert back to percentage
                        textAnchor: "start",
                        dx: 4,
                        fill: "currentColor",
                        stroke: "white",
                        maxRadius: 10,
                        fontSize: 12
                    })
                ),

                // Interactive opacity on the areas
                () => {
                    const style = document.createElement("style");
                    style.textContent = `
                        g[aria-label=area] path {fill-opacity: 0.1; transition: fill-opacity .2s;}
                        g[aria-label=area]:hover path:not(:hover) {fill-opacity: 0.05; transition: fill-opacity .2s;}
                        g[aria-label=area] path:hover {fill-opacity: 0.3; transition: fill-opacity .2s;}
                    `;
                    return style;
                }
            ]
        });

        // Add chart to DOM
        document.getElementById("chart").appendChild(chart);
    </script>
</body>
</html>